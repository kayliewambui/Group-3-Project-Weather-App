"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const utils_1 = require("@typescript-eslint/utils");
const util = __importStar(require("../util"));
exports.default = util.createRule({
    name: 'consistent-type-imports',
    meta: {
        type: 'suggestion',
        docs: {
            description: 'Enforce consistent usage of type imports',
            recommended: false,
        },
        messages: {
            typeOverValue: 'All imports in the declaration are only used as types. Use `import type`.',
            someImportsAreOnlyTypes: 'Imports {{typeImports}} are only used as types.',
            aImportIsOnlyTypes: 'Import {{typeImports}} is only used as types.',
            someImportsInDecoMeta: 'Type imports {{typeImports}} are used by decorator metadata.',
            aImportInDecoMeta: 'Type import {{typeImports}} is used by decorator metadata.',
            valueOverType: 'Use an `import` instead of an `import type`.',
            noImportTypeAnnotations: '`import()` type annotations are forbidden.',
        },
        schema: [
            {
                type: 'object',
                properties: {
                    prefer: {
                        enum: ['type-imports', 'no-type-imports'],
                    },
                    disallowTypeAnnotations: {
                        type: 'boolean',
                    },
                    fixStyle: {
                        enum: ['separate-type-imports', 'inline-type-imports'],
                    },
                },
                additionalProperties: false,
            },
        ],
        fixable: 'code',
    },
    defaultOptions: [
        {
            prefer: 'type-imports',
            disallowTypeAnnotations: true,
            fixStyle: 'separate-type-imports',
        },
    ],
    create(context, [option]) {
        var _a, _b;
        const prefer = (_a = option.prefer) !== null && _a !== void 0 ? _a : 'type-imports';
        const disallowTypeAnnotations = option.disallowTypeAnnotations !== false;
        const fixStyle = (_b = option.fixStyle) !== null && _b !== void 0 ? _b : 'separate-type-imports';
        const sourceCode = context.getSourceCode();
        const sourceImportsMap = {};
        return Object.assign(Object.assign({}, (prefer === 'type-imports'
            ? {
                // prefer type imports
                ImportDeclaration(node) {
                    var _a;
                    const source = node.source.value;
                    // sourceImports is the object containing all the specifics for a particular import source, type or value
                    const sourceImports = (_a = sourceImportsMap[source]) !== null && _a !== void 0 ? _a : (sourceImportsMap[source] = {
                        source,
                        reportValueImports: [],
                        typeOnlyNamedImport: null,
                        valueOnlyNamedImport: null,
                        valueImport: null, // if only value imports
                    });
                    if (node.importKind === 'type') {
                        if (!sourceImports.typeOnlyNamedImport &&
                            node.specifiers.every(specifier => specifier.type === utils_1.AST_NODE_TYPES.ImportSpecifier)) {
                            // definitely import type { TypeX }
                            sourceImports.typeOnlyNamedImport = node;
                        }
                    }
                    else {
                        if (!sourceImports.valueOnlyNamedImport &&
                            node.specifiers.every(specifier => specifier.type === utils_1.AST_NODE_TYPES.ImportSpecifier)) {
                            sourceImports.valueOnlyNamedImport = node;
                            sourceImports.valueImport = node;
                        }
                        else if (!sourceImports.valueImport &&
                            node.specifiers.some(specifier => specifier.type === utils_1.AST_NODE_TYPES.ImportDefaultSpecifier)) {
                            sourceImports.valueImport = node;
                        }
                    }
                    const typeSpecifiers = [];
                    const inlineTypeSpecifiers = [];
                    const valueSpecifiers = [];
                    const unusedSpecifiers = [];
                    for (const specifier of node.specifiers) {
                        if (specifier.type === utils_1.AST_NODE_TYPES.ImportSpecifier &&
                            specifier.importKind === 'type') {
                            inlineTypeSpecifiers.push(specifier);
                            continue;
                        }
                        const [variable] = context.getDeclaredVariables(specifier);
                        if (variable.references.length === 0) {
                            unusedSpecifiers.push(specifier);
                        }
                        else {
                            const onlyHasTypeReferences = variable.references.every(ref => {
                                var _a, _b;
                                /**
                                 * keep origin import kind when export
                                 * export { Type }
                                 * export default Type;
                                 */
                                if (((_a = ref.identifier.parent) === null || _a === void 0 ? void 0 : _a.type) ===
                                    utils_1.AST_NODE_TYPES.ExportSpecifier ||
                                    ((_b = ref.identifier.parent) === null || _b === void 0 ? void 0 : _b.type) ===
                                        utils_1.AST_NODE_TYPES.ExportDefaultDeclaration) {
                                    if (ref.isValueReference && ref.isTypeReference) {
                                        return node.importKind === 'type';
                                    }
                                }
                                if (ref.isValueReference) {
                                    let parent = ref.identifier.parent;
                                    let child = ref.identifier;
                                    while (parent) {
                                        switch (parent.type) {
                                            // CASE 1:
                                            // `type T = typeof foo` will create a value reference because "foo" must be a value type
                                            // however this value reference is safe to use with type-only imports
                                            case utils_1.AST_NODE_TYPES.TSTypeQuery:
                                                return true;
                                            case utils_1.AST_NODE_TYPES.TSQualifiedName:
                                                // TSTypeQuery must have a TSESTree.EntityName as its child, so we can filter here and break early
                                                if (parent.left !== child) {
                                                    return false;
                                                }
                                                child = parent;
                                                parent = parent.parent;
                                                continue;
                                            // END CASE 1
                                            //////////////
                                            // CASE 2:
                                            // `type T = { [foo]: string }` will create a value reference because "foo" must be a value type
                                            // however this value reference is safe to use with type-only imports.
                                            // Also this is represented as a non-type AST - hence it uses MemberExpression
                                            case utils_1.AST_NODE_TYPES.TSPropertySignature:
                                                return parent.key === child;
                                            case utils_1.AST_NODE_TYPES.MemberExpression:
                                                if (parent.object !== child) {
                                                    return false;
                                                }
                                                child = parent;
                                                parent = parent.parent;
                                                continue;
                                            // END CASE 2
                                            default:
                                                return false;
                                        }
                                    }
                                }
                                return ref.isTypeReference;
                            });
                            if (onlyHasTypeReferences) {
                                typeSpecifiers.push(specifier);
                            }
                            else {
                                valueSpecifiers.push(specifier);
                            }
                        }
                    }
                    if ((node.importKind === 'value' && typeSpecifiers.length) ||
                        (node.importKind === 'type' && valueSpecifiers.length)) {
                        sourceImports.reportValueImports.push({
                            node,
                            typeSpecifiers,
                            valueSpecifiers,
                            unusedSpecifiers,
                            inlineTypeSpecifiers,
                        });
                    }
                },
                'Program:exit'() {
                    for (const sourceImports of Object.values(sourceImportsMap)) {
                        if (sourceImports.reportValueImports.length === 0) {
                            // nothing to fix. value specifiers and type specifiers are correctly written
                            continue;
                        }
                        for (const report of sourceImports.reportValueImports) {
                            if (report.valueSpecifiers.length === 0 &&
                                report.unusedSpecifiers.length === 0 &&
                                report.node.importKind !== 'type') {
                                context.report({
                                    node: report.node,
                                    messageId: 'typeOverValue',
                                    *fix(fixer) {
                                        yield* fixToTypeImportDeclaration(fixer, report, sourceImports);
                                    },
                                });
                            }
                            else {
                                const isTypeImport = report.node.importKind === 'type';
                                // we have a mixed type/value import or just value imports, so we need to split them out into multiple imports if separate-type-imports is configured
                                const importNames = (isTypeImport
                                    ? report.valueSp